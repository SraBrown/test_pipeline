pipeline {
    agent any
    tools {
        maven 'Maven Apache'

    }
    parameters {
        choice(name: 'ENVIRONMENT', choices: ['dev', 'test', 'prod'], description: 'Environment to deploy')
        booleanParam(name: 'EXECUTE_JAR', defaultValue: true, description: 'Enable JAR')
        string(name: 'URL_GIT', defaultValue: 'https://github.com/your-repo/your-project.git', description: 'Branch Specifier')
        string(name: 'BRANCH', defaultValue: 'develop', description: 'Branch Specifier')
        string(name: 'GITLAB_CREDENTIALS', defaultValue: 'GITLAB_CREDENTIALS', description: 'Name Token')
        choice(name: 'EXECUTE_SONAR', choices: ['Yes', 'No'], description: 'Execute SONAR?')
        choice(name: 'EXECUTE_JACOCO', choices: ['Yes', 'No'], description: 'Execute JACOCO?')
        string(name: 'JAVA_HOME', defaultValue: '/opt/java/openjdk', description: 'Enter Directory Java')
    }
    environment {
        SONARQUBE_SERVER = 'SonarQube' // Name of the SonarQube server in Jenkins
        SONAR_PROJECT_KEY = 'ASSDA'
        SONAR_PROJECT_NAME = 'ASSDA'
        SONAR_PROJECT_VERSION = '1.0'
        TOKEN_SONAR ='c3F1XzY1YzE5MWMwNjkzM2IxYzNhZDNjZjdmZmY5YTdiNTk5NTRmNjdhMDA='
        JACOCO_REPORT_PATH = 'target/jacoco.exec'      // Ruta al archivo de cobertura de JaCoCo
    }
    stages {
        stage('Checkout') {
            steps {
                echo 'Checkout the JAR!'
                checkout scmGit(branches: [[name: '$BRANCH']], extensions: [], userRemoteConfigs:
                        [[credentialsId: "${params.GITLAB_CREDENTIALS}", url: "${params.URL_GIT}"]])

            }
        }
       stage('Build and Install') {
                steps {
                    script {
                        if (params.EXECUTE_JAR) {
                            echo 'Starting Build ,params.EXECUTE_JAR=true!'
                            //sh 'mvn clean test -Pcoverage'
                            sh 'mvn clean package'
                        }
                    }
                }
            }
        
        
        
        stage('Prepare Jacoco') {
            when {
                            expression { params.EXECUTE_JACOCO == 'Yes' }
                        }
                    steps {
                        script {
                        echo 'Iniciar descarga de jacoco'
                            // Ruta donde se almacenarán los JARs
                            def jacocoPath = "${env.WORKSPACE}/jacoco"
                            // Crea el directorio si no existe
                            sh "mkdir -p ${jacocoPath}"

                            // Descarga jacocoagent.jar y jacococli.jar
                            sh """
                                curl -L -o ${jacocoPath}/jacocoagent.jar https://repo1.maven.org/maven2/org/jacoco/org.jacoco.agent/0.8.8/org.jacoco.agent-0.8.8-runtime.jar
                                curl -L -o ${jacocoPath}/jacococli.jar https://repo1.maven.org/maven2/org/jacoco/org.jacoco.cli/0.8.8/org.jacoco.cli-0.8.8-nodeps.jar
                            """

                            // Verifica que los archivos se hayan descargado
                            sh "ls -l ${jacocoPath}"
                            sh 'mvn clean verify -Djacoco.agent.version=0.8.7 -Djacoco.include.from=target/classes -Djacoco.output=target/jacoco'
                        }
                    }
                }

     
        stage('JaCoCo Report') {
            steps {
                // Generar reporte de JaCoCo usando el archivo de ejecución
                script {
                    // Si deseas generar el reporte HTML o en otro formato, puedes hacerlo aquí.
                    sh 'mvn jacoco:report'
                }
            }
        }
/*
        stage('Dependency Analysis') {
            steps {
                // Run the OWASP Dependency-Check plugin
                sh 'mvn org.owasp:dependency-check-maven:check'
            }
        }
   stage('SonarQube Analysis') {
           when {
                expression { params.EXECUTE_SONAR == 'Yes' }
            }
            steps {
                script {
                    // Run SonarQube analysis
                    withSonarQubeEnv('SonarQube') {
                        sh "sonar-Dsonar.projectKey=${SONAR_PROJECT_KEY} -Dsonar.projectName=${SONAR_PROJECT_NAME} -Dsonar.sources=src -Dsonar.host.url=http://sonar:9000 -Dsonar.login=${TOKEN_SONAR}"
                    }
                }
            }
        }
        */

        stage('SonarQube Analysis') {
            when {
                      expression { params.EXECUTE_SONAR == 'Yes' }
                    }
          steps {
                withSonarQubeEnv('SonarQube') {
                   sh "mvn clean verify sonar:sonar \
                         -Dsonar.projectKey=ASSDA \
                         -Dsonar.host.url=http://localhost:9000 \
                         -Dsonar.login=token_sonar"
                }
            }
        }
/*
  stage('Quality Gate') {
        when {
                expression { params.EXECUTE_SONAR == 'Yes' }
            }
            steps {
                script {
                    // Wait for SonarQube analysis to finish and check quality gate status
                    timeout(time: 5, unit: 'MINUTES') {
                        waitForQualityGate abortPipeline: true
                    }
                }
            }
        }
*/
    stage('Archive') {
            steps {
                // Archive the JAR file (adjust the path to your output file as necessary)
                archiveArtifacts artifacts: 'target/*.jar', fingerprint: true
            }
        }
    }
}
